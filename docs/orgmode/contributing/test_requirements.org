#+TITLE: Testing & Environment Requirements
#+OPTIONS: toc:nil todo:nil num:nil author:t title:t
#+STARTUP: content

* Development Environment
This project manages conflicting binary dependencies through isolated ~pixi~
environments. We avoid a monolithic environment to prevent version resolution
failures and import-time crashes.

** Initial Setup
#+BEGIN_SRC shell
pixi install
#+END_SRC

* Local Development & Editable Installs
By default, the ~rgpycrumbs~ dispatcher runs scripts using ~uv run~. This enforces strict environment isolation by resolving and fetching a script's PEP 723 inline dependencies on the fly. 

While excellent for reproducibility, this behavior bypasses your local Python environment. If you are actively developing a dependent package (e.g., you installed it locally via ~pip install -e .~ or ~pixi add --editable~), ~uv run~ will ignore your local edits and fetch the published version instead.

To force ~rgpycrumbs~ to use your active environment and respect your editable installs, use the ~--dev~ flag:

#+BEGIN_SRC shell
# Standard execution (Isolated: uv resolves dependencies from scratch)
rgpycrumbs mygroup myscript

# Development execution (Active Env: uses sys.executable, respects editable installs)
rgpycrumbs --dev mygroup myscript
#+END_SRC

** Workflow for Dependent Packages
1. Activate your desired ~pixi~ environment (e.g., ~pixi shell -e test~).
2. Install your dependent package in editable mode if not already managed by pixi (e.g., ~pip install -e /path/to/local/dependency~).
3. Run your script using the ~--dev~ flag to test your local package modifications: ~rgpycrumbs --dev <group> <script>~.
* Testing Guidelines
The test suite utilizes custom markers to scope tests to specific environments. 
This prevents ~ModuleNotFoundError~ during the ~pytest~ collection phase.

** Adding New Tests
When creating a new test file, you must protect the collection phase:

- Define requirements :: Add any required external modules to the 
  ~ENVIRONMENT_REQUIREMENTS~ dictionary in ~tests/conftest.py~.
- Guard imports :: Call ~skip_if_not_env("marker_name")~ at the top of your test 
  file. This must occur before you import any package modules that depend on 
  external binaries.
- Mark your tests :: Assign the corresponding marker to the file or functions.

** Example Test Structure
#+BEGIN_SRC python
import pytest
from tests.conftest import skip_if_not_env

# Guard collection: prevents imports from executing if dependencies are missing
skip_if_not_env("my_marker")

# Imports are now safe to execute
from rgpycrumbs.submodule.logic import core_feature

def test_feature_execution():
    assert core_feature() is True
#+END_SRC

** Available Markers & Environments
The following markers and their corresponding ~pixi~ environments are available:

| Marker | Environment | Dependencies | What it tests |
|------------+-------------+--------------------+---------------------------------------|
| ~pure~ | ~test~ | ~numpy~ | Core utilities, basetypes, interpolation |
| ~align~ | ~test~ | ~ase~, ~numpy~ | Structure analysis, alignment |
| ~fragments~ | ~fragments~ | ~ase~, ~tblite~ | Fragment detection with tight-binding |
| ~surfaces~ | ~surfaces~ | ~jax~ | Surface fitting kernels and models |
| ~ptm~ | ~ptm~ | ~ase~, ~ovito~ | Polyhedral template matching |
| ~eon~ | ~eonmlflow~ | ~ase~, ~eon~ | eOn integration |
| ~ira~ | (requires ~ira_mod~) | ~ira_mod~ | IRA matching and RMSD comparison |

** Running Tests
Execute tests within the specific environment that provides the necessary
dependencies:

#+BEGIN_SRC shell
# Run tests for a specific suite
pixi run -e <env_name> pytest -m <marker_name>

# Examples
pixi run -e test pytest -m pure
pixi run -e test pytest -m align
pixi run -e surfaces pytest -m surfaces
pixi run -e fragments pytest -m fragments
#+END_SRC
